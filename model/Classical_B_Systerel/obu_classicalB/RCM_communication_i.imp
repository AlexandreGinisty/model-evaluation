/* RCM_communication_i
 * Author: Marielle Petit-Doche <marielle.doche@systerel.fr> --Systerel
 * Creation date: 14/05/13
 
  * Licensed under the EUPL V.1.1 or - as soon they will be approved by
 * the European Commission - subsequent versions of the EUPL (the
 * "Licence");
 * You may not use this work except in compliance with the Licence.

 * You may obtain a copy of the Licence at:
 *   http://joinup.ec.europa.eu/software/page/eupl/licence-eupl

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the Licence is distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied.

 * See the Licence for the specific language governing permissions and
 * limitations under the Licence.
 */
IMPLEMENTATION
   RCM_communication_i
REFINES
   RCM_communication

SEES
    RCM_types
    
IMPORTS
    RCM_session

INITIALISATION
   connected_equipment := {} ;
   connection_state := t_equipment * { no_connection } ;
   communication_session_requested := TRUE
   
LOCAL_OPERATIONS
    manage_single_communication(p_equip) =
    PRE
        p_equip :  t_equipment
    THEN
        skip
    END 
    

OPERATIONS
   
    //3.5.3 Establishing a communication session
    
   manage_single_communication ( p_equip ) =
   BEGIN
//3.5.3.4 The on-board shall establish a communication session
//a) At Start of Mission (only if level 2 or 3).
//b) If ordered from trackside.
//c) If a mode change, not considered as an End of Mission, has to be reported to the RBC (only if level 2 or 3)
//d) If the driver has manually changed the level to 2 or 3
//e) When the train front reaches the end of an announced radio hole
//f) When the previous communication session is considered as terminated due to loss of safe radio connection (refer to 3.5.4.2.1)
//g) When a Start of Mission procedure, during which no communication session could be established, is completed in level 2 or 3
//3.5.3.4.1 In respect of a), b), c), d) and e) of 3.5.3.4, the on-board shall not establish a new communication session with an RBC/RIU in case a communication session is currently being established or is already established with this RBC/RIU.



// Check communication condition  TODO 



		IF equipment_class (p_equip) = RBC THEN

           establish_communication_to_RBC(p_equip) ;
           establish_communication_from_RBC(p_equip) ;
           establish_communication_to_Accepting_RBC(p_equip) ;
           maintain_communication(p_equip) ;
           terminate_communication(p_equip)
       ELSIF equipment_class (p_equip) = RIU THEN
           establish_communication_to_RIU(p_equip) ;
           maintain_communication(p_equip) ;
           terminate_communication(p_equip)
       ELSIF equipment_class (p_equip) = OBU THEN
           //3.5.3.3 Note: Only communication sessions between an ERTMS/ETCS on-board equipment and a trackside equipment (RBC or Radio Infill Unit) are considered here.
           // a fault can occur
           skip
       ELSE
           // undefined equipment -  dead code  this branch shall never be reached
           // a fault can occur
           skip
       END
   END
   ;

   manage_communication =
     VAR
       l_next,
       l_equipment
   IN
//3.5.3.1 It shall be possible for ERTMS/ETCS on-board equipment and RBC to initiate a communication session.
       l_next := TRUE ;
       l_equipment := c_equipment_undef ;
       WHILE l_next = TRUE DO
           l_equipment := l_equipment + 1 ;
           l_next := bool(l_equipment /= c_max_equipment) ;
           manage_single_communication (l_equipment) 
        INVARIANT
            l_next = bool(l_equipment /= c_max_equipment) &
            l_equipment : t_equipment
                 //  connected_equipment , connection_state , communication_session_requested : ( connected_equipment <: t_equipment & c_current_equipment /: connected_equipment & connected_equipment <: dom ( equipment_class |> { RBC , RIU } ) & connection_state : t_equipment --> t_communication_state & connection_state ( c_equipment_undef ) = no_connection & connection_state [ dom ( equipment_class |> { OBU } ) ] <: { no_connection } )
      VARIANT
         c_max_equipment - l_equipment

	  END	
	END
   ;

   register_to_radio_network =
   BEGIN
       skip
   END
   ;

   manage_safe_indication =
   BEGIN
       skip
   END


END
